<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Filtering Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .result { font-weight: bold; }
        .success { color: green; }
        .failure { color: red; }
        .disabled { color: #999; text-decoration: line-through; }
        .available { color: #000; }
        pre { background: #f5f5f5; padding: 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Dynamic Filtering Test - T25I Issue</h1>
    <p>Testing the fix for T25I + Wide Frame issue where unavailable options aren't being disabled.</p>
    
    <div id="results"></div>

    <script type="module">
        // Mock environment
        window.import = { meta: { env: { DEV: true } } };

        // Mock Supabase data based on our investigation
        const mockProductLineOptions = [
            { id: 100, product_lines_id: 19, item: "1", collection: "frame_thicknesses" },
            { id: 101, product_lines_id: 19, item: "2", collection: "frame_thicknesses" },
            // Add mirror styles for product line 19
            { id: 102, product_lines_id: 19, item: "16", collection: "mirror_styles" },
            { id: 103, product_lines_id: 19, item: "1", collection: "mirror_styles" },
            // Add light directions 
            { id: 104, product_lines_id: 19, item: "1", collection: "light_directions" },
            { id: 105, product_lines_id: 19, item: "2", collection: "light_directions" }
        ];

        const mockProducts = [
            // T25I - only exists with thin frame (key=2)
            { 
                id: 1729, name: "T25I", sku_code: "T25i", 
                mirror_style: 16, light_direction: 2, 
                frame_thickness: { key: 2, collection: "frame_thicknesses" },
                product_line: 19, active: true 
            },
            // Add some other products to show variety
            {
                id: 1750, name: "T26I", sku_code: "T26i",
                mirror_style: 17, light_direction: 2,
                frame_thickness: { key: 2, collection: "frame_thicknesses" },
                product_line: 19, active: true
            },
            // W01D - wide frame example
            {
                id: 1749, name: "W01D", sku_code: "W01d",
                mirror_style: 1, light_direction: 1,
                frame_thickness: { key: 1, collection: "frame_thicknesses" },
                product_line: 19, active: true
            }
        ];

        // Mock the filtering service with our test data
        let productLineOptionsCache = mockProductLineOptions;
        let productOverridesCache = [];
        let productsCache = mockProducts;

        // Copy the fixed filtering function
        function getFilteredOptions(currentSelection, productLineId) {
            const result = {
                available: {},
                disabled: {},
                all: {}
            };

            if (!productLineId) {
                return result;
            }

            // Get product line default options (defines what fields should appear)
            const productLineOptions = productLineOptionsCache.filter(
                option => option.product_lines_id === productLineId
            );

            // Group by collection - this defines the base UI fields
            const baseOptionsByCollection = productLineOptions.reduce((acc, option) => {
                if (!acc[option.collection]) {
                    acc[option.collection] = [];
                }
                acc[option.collection].push(option.item);
                return acc;
            }, {});

            // Determine filtering level based on selections
            const hasProductLine = !!productLineId;
            const hasMirrorStyle = !!currentSelection.mirror_styles;

            if (hasProductLine && !hasMirrorStyle) {
                // LEVEL 1: Product line only - show ALL default options
                Object.entries(baseOptionsByCollection).forEach(([collection, items]) => {
                    const uniqueItems = [...new Set(items)];
                    result.all[collection] = uniqueItems;
                    result.available[collection] = uniqueItems; // Show everything at level 1
                    result.disabled[collection] = []; // Nothing disabled at level 1
                });

            } else if (hasProductLine && hasMirrorStyle) {
                // LEVEL 2: Product line + mirror style - filter actual products
                const filteredProducts = productsCache.filter(p => 
                    p.product_line === productLineId &&
                    p.mirror_style?.toString() === currentSelection.mirror_styles
                );

                // Extract available options from these specific products
                const availableFromProducts = {};

                if (filteredProducts.length > 0) {
                    // Direct product fields with proper type safety
                    availableFromProducts.mirror_styles = Array.from(
                        new Set(
                            filteredProducts
                                .map(p => p.mirror_style?.toString())
                                .filter((item) => Boolean(item))
                        )
                    );

                    availableFromProducts.light_directions = Array.from(
                        new Set(
                            filteredProducts
                                .map(p => p.light_direction?.toString())
                                .filter((item) => Boolean(item))
                        )
                    );

                    // Frame thickness from JSON field with proper type safety
                    const frameThicknesses = filteredProducts
                        .map(p => p.frame_thickness?.key?.toString())
                        .filter((item) => Boolean(item));
                    // ALWAYS set the array, even if empty - this is critical for proper filtering
                    availableFromProducts.frame_thicknesses = Array.from(new Set(frameThicknesses));

                } else {
                    // No products match current selection - all dependent collections should be empty
                    availableFromProducts.mirror_styles = [];
                    availableFromProducts.light_directions = [];
                    availableFromProducts.frame_thicknesses = [];
                }

                // Build result based on actual products
                Object.entries(baseOptionsByCollection).forEach(([collection, items]) => {
                    result.all[collection] = [...new Set(items)];

                    // CRITICAL: Never disable options within the same collection being selected
                    const isCurrentlySelectingThisCollection = Object.keys(currentSelection).some(key =>
                        key === collection || key === `${collection}s` || key.replace(/s$/, '') === collection
                    );

                    if (isCurrentlySelectingThisCollection) {
                        // User is selecting from THIS collection - show ALL options, never disable within same collection
                        result.available[collection] = [...items];
                        result.disabled[collection] = [];
                    } else {
                        // Different collection - apply cross-collection filtering based on products
                        if (collection in availableFromProducts) {
                            // Collection has product-specific filtering defined
                            const availableItems = availableFromProducts[collection];
                            result.available[collection] = [...availableItems];
                            result.disabled[collection] = items.filter(item => !availableItems.includes(item));
                        } else {
                            // No product-specific filtering for this collection - keep all defaults available
                            result.available[collection] = [...items];
                            result.disabled[collection] = [];
                        }
                    }
                });
            }

            return result;
        }

        // Test cases
        const testCases = [
            {
                name: "Level 1: Product line only (no mirror style selected)",
                selection: {},
                productLine: 19,
                expected: {
                    description: "Should show all default options, nothing disabled",
                    disabled: { frame_thicknesses: [] }
                }
            },
            {
                name: "Level 2: T25I mirror style selected (ID 16)",
                selection: { mirror_styles: "16" },
                productLine: 19,
                expected: {
                    description: "Should disable Wide Frame (ID 1), keep Thin Frame (ID 2)",
                    disabled: { frame_thicknesses: ["1"] },
                    available: { frame_thicknesses: ["2"] }
                }
            },
            {
                name: "Level 2: Mirror style 1 selected",
                selection: { mirror_styles: "1" },
                productLine: 19,
                expected: {
                    description: "Should disable Thin Frame (ID 2), keep Wide Frame (ID 1)",
                    disabled: { frame_thicknesses: ["2"] },
                    available: { frame_thicknesses: ["1"] }
                }
            }
        ];

        // Run tests
        const resultsDiv = document.getElementById('results');

        testCases.forEach((testCase, index) => {
            const div = document.createElement('div');
            div.className = 'test-case';
            
            const result = getFilteredOptions(testCase.selection, testCase.productLine);
            
            // Check if test passes
            let passes = true;
            let details = [];
            
            if (testCase.expected.disabled && testCase.expected.disabled.frame_thicknesses) {
                const actualDisabled = result.disabled.frame_thicknesses || [];
                const expectedDisabled = testCase.expected.disabled.frame_thicknesses;
                
                const disabledMatch = JSON.stringify(actualDisabled.sort()) === JSON.stringify(expectedDisabled.sort());
                passes = passes && disabledMatch;
                
                details.push(`Disabled frame_thicknesses: Expected [${expectedDisabled.join(', ')}], Got [${actualDisabled.join(', ')}] ${disabledMatch ? '✓' : '✗'}`);
            }
            
            if (testCase.expected.available && testCase.expected.available.frame_thicknesses) {
                const actualAvailable = result.available.frame_thicknesses || [];
                const expectedAvailable = testCase.expected.available.frame_thicknesses;
                
                const availableMatch = JSON.stringify(actualAvailable.sort()) === JSON.stringify(expectedAvailable.sort());
                passes = passes && availableMatch;
                
                details.push(`Available frame_thicknesses: Expected [${expectedAvailable.join(', ')}], Got [${actualAvailable.join(', ')}] ${availableMatch ? '✓' : '✗'}`);
            }
            
            div.innerHTML = `
                <h3>Test ${index + 1}: ${testCase.name}</h3>
                <p><strong>Selection:</strong> ${JSON.stringify(testCase.selection)}</p>
                <p><strong>Expected:</strong> ${testCase.expected.description}</p>
                <p class="result ${passes ? 'success' : 'failure'}">${passes ? '✓ PASS' : '✗ FAIL'}</p>
                <div><strong>Details:</strong></div>
                <ul>
                    ${details.map(d => `<li>${d}</li>`).join('')}
                </ul>
                <details>
                    <summary>Full Result</summary>
                    <pre>${JSON.stringify(result, null, 2)}</pre>
                </details>
            `;
            
            resultsDiv.appendChild(div);
        });

        // Summary
        const allTests = testCases.length;
        const passedTests = Array.from(resultsDiv.querySelectorAll('.success')).length;
        
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'test-case';
        summaryDiv.innerHTML = `
            <h2>Summary</h2>
            <p class="result ${passedTests === allTests ? 'success' : 'failure'}">
                ${passedTests}/${allTests} tests passed
            </p>
            ${passedTests === allTests ? 
                '<p>🎉 The filtering fix is working correctly! T25I + Wide Frame should now be disabled.</p>' :
                '<p>❌ Some tests failed. The filtering logic needs further adjustment.</p>'
            }
        `;
        resultsDiv.insertBefore(summaryDiv, resultsDiv.firstChild);
    </script>
</body>
</html>